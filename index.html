<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>紫--小梦</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="紫--小梦">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="紫--小梦">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="紫--小梦">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="紫--小梦" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">紫--小梦</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">心怀梦想，志在远方。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-PHP初了解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/01/PHP初了解/" class="article-date">
  <time datetime="2016-09-01T07:38:31.000Z" itemprop="datePublished">2016-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/01/PHP初了解/">PHP初了解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PHP-简介"><a href="#PHP-简介" class="headerlink" title="PHP 简介"></a>PHP 简介</h3><p><strong>PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。</strong></p>
<p><strong>PHP 脚本在服务器上执行。</strong></p>
<p><strong>PHP 文件必须为英文名，防止出现错误；PHP 代码必须加分号。</strong></p>
<ol>
<li>PHP 是 “PHP Hypertext Preprocessor” （超文本预处理器）的缩写。</li>
<li>PHP 是一种被广泛使用的开源脚本语言。</li>
<li>PHP 脚本在服务器上执行。</li>
<li>PHP 可以免费下载和使用。</li>
</ol>
<p>PHP 文件：</p>
<ol>
<li>PHP 文件能够包含文本、HTML、CSS 以及 PHP 代码。</li>
<li>PHP 代码在服务器上执行，而结果以纯文本返回浏览器。</li>
<li>PHP 文件的后缀是 “.php”。</li>
</ol>
<p>PHP 优点：</p>
<ol>
<li>开源</li>
<li>能运行于各种平台（Windows，Linux，Unix，Mac OS X 等等）</li>
<li>兼容几乎所有的服务器</li>
<li>语法简单，极易学习</li>
<li>功能强大，能做大型开发</li>
<li>能够动态生成web页面内容（php代码可以嵌入到html代码中）</li>
</ol>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>通过XAMPP（Apache+MySQL+PHP+Perl）建站集成软件包来安装。使用XAMPP目的是因为手动安装Apache+MySQL+PHP环境过于复杂，使用XAMPP只需点击安装即可。</p>
<p><strong>XAMPP常见问题</strong></p>
<ol>
<li>Apache启动失败：运行sudo apachectl stop</li>
<li>MySQL启动失败：（1）sudo /Library/StartupItems/MySQLCOM/MySQLCOM stop （2）使用ps-eflgrep mysql查找进程号，通过kill杀掉进程</li>
</ol>
<h3 id="PHP-基础语法"><a href="#PHP-基础语法" class="headerlink" title="PHP 基础语法"></a>PHP 基础语法</h3><p><strong>PHP脚本以&lt;?php开头，以?&gt;结尾：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	//此处是 PHP 代码</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p><strong>PHP注释：</strong></p>
<ol>
<li>多行注释</li>
<li>单行注释</li>
<li>文档注释</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.多行注释</span><br><span class="line">/*</span><br><span class="line">	注释内容</span><br><span class="line">	注释内容</span><br><span class="line">*/</span><br><span class="line">2.单行注释</span><br><span class="line">//注释内容</span><br><span class="line">3.文档注释</span><br><span class="line">/**</span><br><span class="line">*注释文档</span><br><span class="line">*注释文档</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>变量的声明：</strong></p>
<ol>
<li>变量以$开头，后面跟变量名</li>
<li>变量只能由字母，数字，下划线组成，不能以数字开头</li>
<li>变量名区分大小写</li>
<li>PHP 与 JavaScript 类似，不需要实现声明变量的数据类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$name = &quot;xiaoming&quot;;</span><br><span class="line">$age = 18;</span><br></pre></td></tr></table></figure>
<p><strong>变量的赋值：</strong></p>
<ol>
<li>值赋值：即将赋值表达式的值复制给变量（直接赋值）；</li>
<li>引用赋值：创建的一个变量与另一个变量引用的内容相同（引用相同地址）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$var = &quot;hello&quot;;</span><br><span class="line">$var1 = &amp;$var;//把变量var的引用赋值给var1</span><br></pre></td></tr></table></figure>
<p><strong>变量的变量：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$say = &quot;hello&quot;;</span><br><span class="line">$$say = &quot;world&quot;;//相当于$hello = &quot;world&quot;;</span><br><span class="line">echo $say;//输出hello</span><br><span class="line">echo $hello;//输出world</span><br><span class="line">echo $&#123;$ay&#125;;//输出world</span><br></pre></td></tr></table></figure>
<p><strong>超全局变量：</strong></p>
<p>PHP提供很多预定义变量，用于提供大量与环境有关的信息</p>
<p>打印/输出超全局变量：print_r($_SERVER);</p>
<p>1.<strong>$_SERVER</strong> 服务器变量，该全局变量包含着服务器和客户端配置及当前请求环境的有关信息</p>
<p>$_SERVER[‘SERVER_NAME’] ： 当前运行脚本所在的服务器的主机名</p>
<p>$_SERVER[‘REMOTE_ADDR’] ： 客户端IP地址</p>
<p>$_SERVER[‘REQUEST_URI’] ： URL的路径部分</p>
<p>$_SERVER[‘HTTP_USER_AGENT’] ： 操作系统和浏览器的有关信息</p>
<p>2.<strong>$_GET</strong>    该变量包含使用GET方法传递的参数地有关信息</p>
<p>3.<strong>$_POST</strong> 该变量包含使用POST方法传递的参数地有关信息</p>
<p>4.<strong>$_REQUEST</strong> 该变量记录着通过各种输入方法传递给脚本的变量，如GET POST，但是不建议使用，因为它不安全而且速度较慢</p>
<p>5.<strong>$_COOKIE</strong> cookie变量数组</p>
<p>6.<strong>$_SESSION</strong> 会话变量数组</p>
<p>7.<strong>$_FILES</strong> 与上传文件有关的变量数组</p>
<p>8.<strong>$_ENV</strong> 环境变量数组</p>
<p>9.<strong>$GLOBALS</strong> 所有全局变量数组</p>
<p><strong>常量：</strong></p>
<p>常量是指在程序执行中无法修改的值。</p>
<ol>
<li>在脚本执行期间该值不能改变；</li>
<li>常量对大小写敏感，通常常量名总是大写；</li>
<li>常量是全局的，可以在脚本的任何地方引用；</li>
<li>常量分为内置常量和自定义常量；</li>
<li>常量使用define()函数定义。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;PI&apos;,3.1415926,false);//第三个参数：是否对大小写敏感（默认false对大小写敏感；true对大小写不敏感）</span><br><span class="line">echo PI;//3.1415926</span><br></pre></td></tr></table></figure>
<p>一、内置常量</p>
<p><strong>PHP_OS</strong> PHP 所在操作系统的名称</p>
<p><strong>PHP_VERSION</strong> 当前PHP 的版本号</p>
<p>二、魔术常量</p>
<p><code>__LINE__</code> 文件中的当前行号</p>
<p><code>__FILE__</code> 文件的完整路径和文件名</p>
<p><code>__FUNCTION__</code> 函数名称</p>
<p><code>__CLASS__</code> 类的名称</p>
<p><code>__METHOD__</code> 类的方法名</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h6 id="标量数据类型"><a href="#标量数据类型" class="headerlink" title="标量数据类型"></a>标量数据类型</h6><p><strong>一、字符串</strong></p>
<p>字符串有三种定义方式：单引号，双引号，定界符(heredoc)；</p>
<p>单引号字符串中出现的变量不会被变量的值替代；</p>
<p>双引号字符串中最重要的一点是其中的变量会被变量值替代；</p>
<p>如果遇到美元符号($)，解析器会尽可能多地取得后面的字符以组成一个合法的变量名，如果想明确的制定名字的结束，用<code>{}</code>把变量名包括起来。</p>
<p>字符串定界的方法使用定界符语法<code>&lt;&lt;&lt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$str = &lt;&lt;&lt; EOD</span><br><span class="line">Example of string</span><br><span class="line">using heredoc syntax.</span><br><span class="line">EOD;</span><br><span class="line">echo $str;</span><br></pre></td></tr></table></figure>
<p>在PHP 定界符中的任何特殊字符，都不需要转义，PHP 定界符中的PHP变量会被正常的用其值来替换。</p>
<p><code>使用定界符要注意：结束标识符所在的行不能包含任何其他字符，这意味着该标识符不能被缩进，在分号之前、之后都不能有任何空格或制表符。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串转义</span><br><span class="line">\n		换行</span><br><span class="line">\r		回车</span><br><span class="line">\t		水平制表符(tab键)</span><br><span class="line">\\		\(反斜杠)</span><br><span class="line">\$		$(美元符)</span><br><span class="line">\&quot;		&quot;(双引号)</span><br></pre></td></tr></table></figure>
<p><strong>二、整型(integer)</strong></p>
<p>整型是没有小数的数字。整型必须有至少一个数字（0-9）；整型不能包含逗号或空格；整型不能有小数点；整型正负均可；可以用三种格式规定整型：十进制、十六进制或八进制。</p>
<p><strong>三、浮点型(float，double)</strong></p>
<p>浮点数是有小数点或指数形式的数字，分为单精度(float)和双精度(double)</p>
<p><strong>四、布尔型(bool)</strong></p>
<p>布尔型指true或false。</p>
<h6 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h6><p><strong>一、数组</strong></p>
<p>数组在一个变量中存储多个值。</p>
<p><strong>二、对象</strong></p>
<h6 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h6><p><strong>一、资源</strong></p>
<p><code>$fh = fopen(&quot;text.txt&quot;,&quot;r&quot;);</code></p>
<p><strong>二、null</strong></p>
<p>null 无，表示没有值，null不表示空格，也不表示0。</p>
<p>以下情况认为是null：</p>
<ol>
<li>没有设置为任何预定义的变量；</li>
<li>明确的赋值为null；</li>
<li>使用函数unset()清除。</li>
</ol>
<h6 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h6><p>因PHP 对于类型定义非常的松散，所以有时候会根据引用变量的环境，将变量自动转换为最适合的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$num = 5;</span><br><span class="line">$str = &quot;15&quot;;</span><br><span class="line">echo $num + $str;</span><br><span class="line"></span><br><span class="line">$str = &quot;100 hehe&quot;;</span><br><span class="line">$num = 200;</span><br><span class="line">echo $num + $str;</span><br><span class="line"></span><br><span class="line">$str = &quot;1.5&quot;;</span><br><span class="line">if($str)&#123; //if判断为true</span><br><span class="line">	echo &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="类型相关函数"><a href="#类型相关函数" class="headerlink" title="类型相关函数"></a>类型相关函数</h6><p><strong>1.gettype()</strong> 返回变量的类型，可能的值有 string、integer、float、boolean、array、object、null、unknown。</p>
<p><strong>2.is_type()</strong> 查看变量是否属于某个类型，是返回TRUE，否返回FALSE。</p>
<p><strong>3.var_dump()</strong> 获取变量的值和类型的详细信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/01/PHP初了解/" data-id="cisn3bgn9001459e86kpr52et" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTML5canvas标签和JavaScript的结合运用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/28/HTML5canvas标签和JavaScript的结合运用/" class="article-date">
  <time datetime="2016-08-28T08:10:24.000Z" itemprop="datePublished">2016-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/28/HTML5canvas标签和JavaScript的结合运用/">HTML5canvas标签和JavaScript的结合运用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Canvas简介"><a href="#Canvas简介" class="headerlink" title="Canvas简介"></a>Canvas简介</h3><p>Canvas是HTML5中重要的元素，其和audio、video元素类似，完全不需要任何外部插件就能运行。</p>
<p>Canvas中文翻译为“画布”。它提供了强大的图形处理功能（绘制，变换，像素处理等）。</p>
<p>Canvas浏览器支持：除IE8及以下不支持外，其他浏览器都支持Canvas。</p>
<h5 id="Canvas标签"><a href="#Canvas标签" class="headerlink" title="Canvas标签"></a>Canvas标签</h5><p><code>&lt;canvas&gt;</code>标签定义图形，<code>&lt;canvas&gt;</code>标签只是图形容器，必须使用脚本来绘制图形。</p>
<p><code>&lt;canvas&gt;您的浏览器不支持canvas&lt;/canvas&gt;</code>canvas标签中的内容在支持的浏览器内，默认为不显示；在不支持的浏览器上才会显示。</p>
<p><strong>canvas属性：</strong>width宽 height高，假如不设置宽高属性，默认为宽300像素高150像素。</p>
<p><strong>在进行图形绘制时，我们是通过context绘图环境进行操作的。</strong></p>
<p>大多数 Canvas 绘图 API 都没有定义在 <code>&lt;canvas&gt;</code> 元素本身上，而是定义在通过画布的 getContext() 方法获得的一个“绘图环境”对象上。</p>
<p><strong>context是canvas的核心。</strong>context字面意思是上下文，我们可以理解为绘图的助手，用于存储操作步骤。</p>
<p><strong>canvas坐标系：</strong>X轴：横向向右为正方向；Y轴：竖向向下为正方向。</p>
<p>canvas标签的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;canvas id=&quot;canvas1&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;</span><br><span class="line">		您的浏览器不支持canvas，请使用高版本的浏览器</span><br><span class="line">	&lt;/canvas&gt;</span><br><span class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		//获取canvas</span><br><span class="line">		var canvas = document.getElementById(&quot;canvas1&quot;);</span><br><span class="line">		//获取绘制环境</span><br><span class="line">		var context = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Canvas基本图形绘制"><a href="#Canvas基本图形绘制" class="headerlink" title="Canvas基本图形绘制"></a>Canvas基本图形绘制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">基本图形绘制</span><br><span class="line"></span><br><span class="line">beginPath()				开始一条路径</span><br><span class="line"></span><br><span class="line">moveTo(x,y)				设置绘制起点</span><br><span class="line"></span><br><span class="line">lineTo(x,y)				设置下一个点</span><br><span class="line"></span><br><span class="line">closePath()				闭合路径，会从当前点连接到起始点，形成一个封闭的路径</span><br><span class="line"></span><br><span class="line">strokeStyle				设置线条的样式（颜色）</span><br><span class="line"></span><br><span class="line">stroke()				绘制线条</span><br><span class="line"></span><br><span class="line">fillStyle				设置填充样式（颜色）</span><br><span class="line"></span><br><span class="line">fill()					填充当前绘图</span><br><span class="line"></span><br><span class="line">lineWidth				设置线宽</span><br><span class="line"></span><br><span class="line">strokeRect(x,y,w,h)			绘制矩形边框，x，y分别为起始绘制x轴y轴的位置，w为绘制宽度，h为绘制高度</span><br><span class="line"></span><br><span class="line">fillRect(x,y,w,h)			填充矩形边框</span><br><span class="line"></span><br><span class="line">arc(x,y,radius,startAngle,endAngle,anticlockwise)</span><br><span class="line"></span><br><span class="line">x,y：圆心位置	；radius：半径；startAngle,endAngle：开始/结束角度（以弧度计算）；anticlockwise：true逆时针false顺时针；</span><br><span class="line"></span><br><span class="line">strokeText()				绘制文字</span><br><span class="line"></span><br><span class="line">fillText()				填充文字</span><br><span class="line"></span><br><span class="line">createLinearGradient(x0,y0,x1,y1);		x0,y0：渐变开始点；x1,y1：渐变结束点</span><br><span class="line"></span><br><span class="line">font 					字体样式</span><br><span class="line"></span><br><span class="line">阴影设置（当设置阴影后，所有的图形都会有阴影）</span><br><span class="line"></span><br><span class="line">shadowColor				阴影颜色</span><br><span class="line"></span><br><span class="line">shadowOffsetX				X方向偏移量</span><br><span class="line"></span><br><span class="line">shadowOffsetY				Y方向偏移量</span><br><span class="line"></span><br><span class="line">shadowBlur				设置阴影的模糊级别</span><br><span class="line"></span><br><span class="line">图形变换</span><br><span class="line"></span><br><span class="line">translate(x,y)				平移（当设置平移时，整个context都会发生移动，也就是坐标系发生变化）</span><br><span class="line"></span><br><span class="line">rotate(deg)				旋转，单位为弧度（当发生旋转时，坐标系也会发生变化，通常搭配translate使用）</span><br><span class="line"></span><br><span class="line">scale(x,y)				缩放，x、y分别为x轴和y轴方向缩放（当发生缩放时，坐标系也会相应的变化）</span><br><span class="line"></span><br><span class="line">状态保存和获取（遵循“先进后出，后进先出”的原则）</span><br><span class="line"></span><br><span class="line">save()					存储绘制状态</span><br><span class="line"></span><br><span class="line">restore()				获取之前的画布状态</span><br><span class="line"></span><br><span class="line">贝塞尔曲线</span><br><span class="line"></span><br><span class="line">quadraticCurvaTo(cpx,cpy,dx,dy)		创建一条表示二次曲线的路径（二次曲线就是二次函数形成的曲线）</span><br><span class="line">cpx,cpy代表控制点，决定曲线的形状	dx,dy代表终点位置</span><br><span class="line"></span><br><span class="line">bezierCurveTo(cpx,cpy,cpx2,cpy2,dx,dy)		创建一条表示贝塞尔曲线的路径</span><br><span class="line">cpx,cpy,cpx2,cpy2代表两个控制点的位置，决定曲线的形状	dx,dy代表终点位置</span><br></pre></td></tr></table></figure>
<p>设置文字及颜色渐变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	#canvasfont&#123;</span><br><span class="line">		box-shadow:0 0 20px lightgreen;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;canvas id=&quot;canvasfont&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;</span><br><span class="line">	您的浏览器不支持；</span><br><span class="line">&lt;/canvas&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var canvasfont = document.getElementById(&quot;canvasfont&quot;);</span><br><span class="line">	var contextfont = canvasfont.getContext(&quot;2d&quot;);</span><br><span class="line">	//设置文字</span><br><span class="line">	var text = &quot;hello World!&quot;;</span><br><span class="line">	contextfont.font = &quot;40px 宋体&quot;;</span><br><span class="line">	//设置渐变</span><br><span class="line">	var fontgradient = contextfont.createLinearGradient(10,50,300,300);</span><br><span class="line">	fontgradient.addColorStop(&quot;0&quot;,&quot;blue&quot;);</span><br><span class="line">	fontgradient.addColorStop(&quot;0.5&quot;,&quot;gold&quot;);</span><br><span class="line">	fontgradient.addColorStop(&quot;1&quot;,&quot;purple&quot;);</span><br><span class="line">	//设置填充颜色</span><br><span class="line">	contextfont.fillStyle = fontgradient;</span><br><span class="line">	//开始填充文字</span><br><span class="line">	contextfont.fillText(text,30,50);</span><br><span class="line">	//填充矩形</span><br><span class="line">	contextfont.fillRect(10,60,280,230);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<pre>
    <style>
        #canvasfont{
            box-shadow:0 0 20px lightgreen;
            background:white;
        }
    </style>
    <canvas id="canvasfont" width="300" height="300">
        您的浏览器不支持；
    </canvas>
    <script>
        var canvasfont = document.getElementById("canvasfont");
        var contextfont = canvasfont.getContext("2d");
        //设置文字
        var text = "hello World!";
        contextfont.font = "40px 宋体";
        //设置渐变
        var fontgradient = contextfont.createLinearGradient(10,50,300,300);
        fontgradient.addColorStop("0","blue");
        fontgradient.addColorStop("0.5","gold");
        fontgradient.addColorStop("1","purple");
        //设置填充颜色
        contextfont.fillStyle = fontgradient;
        //开始填充文字
        contextfont.fillText(text,30,50);
        //填充矩形
        contextfont.fillRect(10,60,280,230);
    </script>
</pre>

<h3 id="Canvas进阶"><a href="#Canvas进阶" class="headerlink" title="Canvas进阶"></a>Canvas进阶</h3><h5 id="globalCompositeOperation属性"><a href="#globalCompositeOperation属性" class="headerlink" title="globalCompositeOperation属性"></a>globalCompositeOperation属性</h5><p>设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上。源图像就是打算放置到画布上的绘图。目标图像是已经放置在画布上的绘图。</p>
<p>其属性值为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">source-over			默认。在目标图像上显示源图像</span><br><span class="line"></span><br><span class="line">source-atop			在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的</span><br><span class="line"></span><br><span class="line">source-in			在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的</span><br><span class="line"></span><br><span class="line">source-out			在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的</span><br><span class="line"></span><br><span class="line">destination-over	在源图像上方显示目标图像</span><br><span class="line"></span><br><span class="line">destination-atop	在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示</span><br><span class="line"></span><br><span class="line">destination-in		在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的</span><br><span class="line"></span><br><span class="line">destination-out		在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的</span><br><span class="line"></span><br><span class="line">lighter				显示源图像 + 目标图像（会使重叠部分颜色叠加）</span><br><span class="line"></span><br><span class="line">copy				显示源图像。忽略目标图像</span><br><span class="line"></span><br><span class="line">source-over			使用异或操作对源图像与目标图像进行组合</span><br></pre></td></tr></table></figure>
<h5 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drawImage(image,x,y)				在canvas中x,y处绘制图片</span><br><span class="line"></span><br><span class="line">drawImage(image,x,y,width,height)	在canvas中x,y处绘制图片，并将其缩放到指定的宽度和高度</span><br><span class="line"></span><br><span class="line">drawImage(image,sourceX,sourceY,sourceWidth,sourceHeight,x,y,width,height)</span><br><span class="line">从图片中切割出一个矩形区域(sourceX,sourceY,sourceWidth,sourceHeight),缩放到指定的宽度和高度，并在canvas中x,y绘制出来</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &quot;图片路径&quot;;</span><br><span class="line">img.onload = function ()&#123;</span><br><span class="line">	//载入图片</span><br><span class="line">	context.drawImage(img,0,0);</span><br><span class="line">	//控制图片</span><br><span class="line">	context.drawImage(img,0,0,canvas,width,canvas.height);</span><br><span class="line">	//裁减</span><br><span class="line">	context.drawImage(img,0,0,100,100,50,50,img.width,img.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h5><p>getImageData()返回ImageData对象，该对象拷贝了画布指定矩形的像素数据。</p>
<p>ImageData中三个属性：width，height和data。width和height表示访问像素区域大小，data是一个包含访问区域所有像素信息的CanvasPixeArray，CanvasPixeArray是一个一维数组。</p>
<p>对ImageData中的每个像素，都存在这四方面的信息，即RGBA值：</p>
<ol>
<li>R - 红色（0-255）</li>
<li>G - 绿色（0-255）</li>
<li>B - 蓝色（0-255）</li>
<li>A - alpha通道（0-255；0是透明，255是完全可见的）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getImageData(x,y,width,height)		获取像素。x,y像素区域雨点坐标，width,height像素区域的宽度和高度</span><br><span class="line"></span><br><span class="line">putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight)</span><br><span class="line">插入像素。imgData像素对象、在画布上显示的x,y、从哪个位置开始展示x,y,展示的宽度,高度(后四个为可选参数)</span><br></pre></td></tr></table></figure>
<p>插入图片示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &quot;图片路径&quot;;</span><br><span class="line">img.onload = function ()&#123;</span><br><span class="line">	context.drawImage(img,0,0);</span><br><span class="line">	var imgData = context.getImageData(0,0,canvas.width,canvas.height);</span><br><span class="line">	var pixs = imgData.data;</span><br><span class="line">	//因为一个参数是以四个参数组合的，所以i+=4</span><br><span class="line">	for(var i=0;i&lt;pixs.length;i+=4)&#123;</span><br><span class="line">		var r = pixs[i];</span><br><span class="line">		var g = pixs[i+1];</span><br><span class="line">		var b = pixs[i+2];</span><br><span class="line">		var gray = parseInt((r+g+b)/3);</span><br><span class="line">		//图像反色</span><br><span class="line">		pixs[i] = gray;</span><br><span class="line">		pixs[i+1] = gray;</span><br><span class="line">		pixs[i+2] = gray;</span><br><span class="line">	&#125;</span><br><span class="line">	context.putImageData(imgData,img.width,img.height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="视频的处理"><a href="#视频的处理" class="headerlink" title="视频的处理"></a>视频的处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function animate()&#123;</span><br><span class="line">	if(!video.ended)&#123;</span><br><span class="line">		//将视频的每一帧都绘制在canvas上</span><br><span class="line">		context.drawImage(video,0,0,canvas,width,canvas.height);</span><br><span class="line">		widow.requestAnimationFrame(animate);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//当视频可以播放时，进行播放调用循环</span><br><span class="line">video.oncanplay = function()&#123;</span><br><span class="line">	video.play();</span><br><span class="line">	window.requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>requestAnimationFrame：动画帧</strong></p>
<p>requestAnimationFrame不需要使用者指定循环间隔时间，浏览器会基于当前页面是否可见、CPU的负荷情况等来自行决定最佳的帧速率，从而更合理地使用CPU。</p>
<p>通过setTimeout和setInterval方法在脚本中可实现动画，但是这样的效果可能不够流畅，而且会占用额外的资源。</p>
<ol>
<li>即使向其传递毫秒为单位的参数，它们也不可能达到毫秒的准确性。这是因为JavaScript是单线程的，可能会发生阻塞。</li>
<li>没有对调用动画的循环机制进行优化。</li>
<li>没有考虑到绘制动画的最佳时机，只是一味地以某个大致的事件间隔来调用循环。</li>
</ol>
<h5 id="图形的存储"><a href="#图形的存储" class="headerlink" title="图形的存储"></a>图形的存储</h5><p>通过toDataURL()来生成图片链接实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	var canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line">	var context = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">	context.fillRect(100,100,100,100);</span><br><span class="line">	//输出</span><br><span class="line">	var url = canvas.toDataURL();</span><br><span class="line">	//在网页中显示</span><br><span class="line">	window.location.href = url;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/28/HTML5canvas标签和JavaScript的结合运用/" data-id="cisn3bglr000f59e8bv9m6r0z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery函数的封装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/26/jQuery函数的封装/" class="article-date">
  <time datetime="2016-08-26T03:38:59.000Z" itemprop="datePublished">2016-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/26/jQuery函数的封装/">jQuery函数的封装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	//首先封装对象的获取方法</span><br><span class="line">	function getEles(arg)&#123;</span><br><span class="line">		//用正则判断开头和结尾是否一个或有多个空格</span><br><span class="line">		var reg1 = /^\s*|\s*$/g;</span><br><span class="line">		arg = arg.replace(reg1,&quot;&quot;);</span><br><span class="line">		//用正则判断中间是否有空格，假如有替换成一个空格</span><br><span class="line">		var reg2 = /\s+/g;</span><br><span class="line">		arg = arg.replace(reg2,&quot; &quot;);</span><br><span class="line">		//将arg通过空格来分割成需要的数组</span><br><span class="line">		var elArr = arg.split(&quot; &quot;);</span><br><span class="line">		var result = [];</span><br><span class="line">		var parents = [document];</span><br><span class="line">		//对arg进行遍历，找到选中的arg</span><br><span class="line">		for(var i=0;i&lt;elArr.length;i++)&#123;</span><br><span class="line">			result = [];</span><br><span class="line">			for(var j=0;j&lt;parents.length;j++)&#123;</span><br><span class="line">				//通过if分别判断需要使用id、class或者tagName选择器</span><br><span class="line">				if(/^#/.test(elArr[i]))&#123;</span><br><span class="line">					//通过字符串截取，去掉单词开头的#号</span><br><span class="line">					var idName = elArr[i].substring(1);</span><br><span class="line">					//找到对应的对象，并将其推入数组</span><br><span class="line">					var idArr = document.getElementById(idName);</span><br><span class="line">					result.push(idArr);</span><br><span class="line">				&#125;else if(/^\./.test(elArr[i]))&#123;</span><br><span class="line">					var className = elArr[i].slice(1);</span><br><span class="line">					var classArr = findClass(parents[j],className);</span><br><span class="line">					for(var k=0;k&lt;classArr.length;k++)&#123;</span><br><span class="line">						result.push(classArr[k]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					var tagArr = parents[j].getElementsByTagName(elArr[i]);</span><br><span class="line">					for(var k=0;k&lt;tagArr.length;k++)&#123;</span><br><span class="line">						result.push(tagArr[k]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			parents = result;</span><br><span class="line">		&#125;</span><br><span class="line">		return parents;</span><br><span class="line">	&#125;</span><br><span class="line">	//封装获取class，主要因为需要兼容IE浏览器</span><br><span class="line">	function findClass(obj,className)&#123;</span><br><span class="line">		if(window.getElementsByClassName)&#123;</span><br><span class="line">			return obj.getElementsByClassName(className);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			//因为IE支持tagName选择器，所以首先找到obj下的所有标签，然后通过正则来找到需要的className</span><br><span class="line">			var tagArr = obj.getElementsByTagName(&quot;*&quot;);</span><br><span class="line">			var classArr = [];</span><br><span class="line">			var reg = new RegExp(&quot;\\b&quot;+className+&quot;\\b&quot;);</span><br><span class="line">			for(var k=0;k&lt;tagArr.length;k++)&#123;</span><br><span class="line">				if(reg.test(tagArr[k].className))&#123;</span><br><span class="line">					classArr.push(tagArr[k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return classArr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//jQuery标志为$，所以封装函数来模拟</span><br><span class="line">	function $(arg)&#123;</span><br><span class="line">		return new Jq(arg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//创建构造函数Jq</span><br><span class="line">	function Jq(arg)&#123;</span><br><span class="line">		//通过创建一个数组来记录选择到的对象</span><br><span class="line">		this.elements = [];</span><br><span class="line">		//因$(arg)能传三种形式，所以对其进行判断</span><br><span class="line">		if(typeof(arg) == &quot;function&quot;)&#123;</span><br><span class="line">			ready(arg);</span><br><span class="line">		&#125;else if(typeof(arg) == &quot;string&quot;)&#123;</span><br><span class="line">			this.elements = getEles(arg);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			this.elements.push(arg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//因Jq(function)的函数是在html、css和js都加载完成时才运行的，所以需要对其进行判断</span><br><span class="line">	function ready(fn)&#123;</span><br><span class="line">		if(window.addEventListener)&#123;</span><br><span class="line">			document.addEventListener(&quot;DOMContentLoaded&quot;,fn,false);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			var oS = document.createElement(&quot;script&quot;);</span><br><span class="line">			oS.defer = true;</span><br><span class="line">			var oH = document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">			oH.appendChild(oS);</span><br><span class="line">			oS.onreadystatechange = function()&#123;</span><br><span class="line">				if(oS.readyState == &quot;complete&quot;)&#123;</span><br><span class="line">					fn();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//对其原型设置click方法，模拟jQuery的click()方法</span><br><span class="line">	Jq.prototype.click = function(fn)&#123;</span><br><span class="line">		for(var i=0;i&lt;this.elements.length;i++)&#123;</span><br><span class="line">			addEvent(&quot;click&quot;,fn,this.elements[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//因添加click时，需要涉及到IE的兼容，所以封装一个函数</span><br><span class="line">	function addEvent(event,fn,obj)&#123;</span><br><span class="line">		if(obj.addEventListener)&#123;</span><br><span class="line">			obj.addEventListener(event,fn,false);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			obj.attachEvent(&quot;on&quot;+event,fn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//对其原型设置on方法，模拟jQuery的on()方法</span><br><span class="line">	Jq.prototype.on = function(event,fn)&#123;</span><br><span class="line">		//因有可能会设置&quot;click mouseleave&quot;等多事件，所以将其分成数组</span><br><span class="line">		var eventArr = event.split(&quot; &quot;);</span><br><span class="line">		for(var i=0;i&lt;this.elements.length;i++)&#123;</span><br><span class="line">			for(var j=0;j&lt;eventArr.length;j++)&#123;</span><br><span class="line">				addEvent(eventArr[j],fn,this.elements[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//对其原型设置.css方法，模拟jQuery的css()方法</span><br><span class="line">	Jq.prototype.css = function()&#123;</span><br><span class="line">		//因css(arg)有三种情况，所以对其分别设置</span><br><span class="line">		if(arguments.length == 1)&#123;</span><br><span class="line">			if(typeof(arguments[0]) == &quot;string&quot;)&#123;</span><br><span class="line">				//当只有一个属性时，是获取属性值，需要返回出去</span><br><span class="line">				return getStyle(this.elements[0],arguments[0]);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				//当其为JSON数据时，就是设置</span><br><span class="line">				for(var i=0;i&lt;this.elements.length;i++)&#123;</span><br><span class="line">					//通过使用for in循环来获得JSON的内容</span><br><span class="line">					for(var keys in arguments[0])&#123;</span><br><span class="line">						setStyle(this.elements[i],keys,arguments[0][keys]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if(arguments.length == 2)&#123;</span><br><span class="line">			for(var i=0;i&lt;this.elements.length;i++)&#123;</span><br><span class="line">				setStyle(this.elements[i],arguments[0],arguments[1]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//因需兼容IE浏览器，所以封装getStyle函数</span><br><span class="line">	function getStyle(obj,style)&#123;</span><br><span class="line">		if(window.getComputedStyle)&#123;</span><br><span class="line">			return getComputedStyle(obj,null)[style];</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return obj.currentStyle(style);</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;</span><br><span class="line">	//因需兼容IE浏览器，所以封装setStyle函数</span><br><span class="line">	function setStyle(obj,styleName,styleValue)&#123;</span><br><span class="line">		//因jQuery中width、height、left、top仅写数字时也是生效的，所以需要加个判断</span><br><span class="line">		var selectArr = [&quot;width&quot;,&quot;height&quot;,&quot;left&quot;,&quot;top&quot;];</span><br><span class="line">		for(var i=0;i&lt;selectArr.length;i++)&#123;</span><br><span class="line">			if(selectArr[i] == styleName)&#123;</span><br><span class="line">				if(typeof(styleValue) == &quot;number&quot;)&#123;</span><br><span class="line">					styleValue = styleValue + &quot;px&quot;;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		obj.style[styleName] = styleValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//对原型设置eq()的方法</span><br><span class="line">	Jq.prototype.eq = function(index)&#123;</span><br><span class="line">		return new Jq(this.elements[index]);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/26/jQuery函数的封装/" data-id="cisn3bgnm001859e8863rkmlu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/24/JavaScript面向对象/" class="article-date">
  <time datetime="2016-08-24T10:39:10.000Z" itemprop="datePublished">2016-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/24/JavaScript面向对象/">JavaScript面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JavaScript面向过程编辑与面向对象编辑"><a href="#JavaScript面向过程编辑与面向对象编辑" class="headerlink" title="JavaScript面向过程编辑与面向对象编辑"></a>JavaScript面向过程编辑与面向对象编辑</h3><p><strong>面向过程编辑：</strong></p>
<ol>
<li><p>注重解决问题的步骤，分析问题需要的每一步，实现函数的依次调用。</p>
</li>
<li><p>代表编程语言：C语言。</p>
</li>
<li><p>面向过程的思维方式就是典型的计算机思维方式：输入数据给处理器，处理器内部执行，然后处理器返回结果。</p>
</li>
</ol>
<p><strong>面向对象编辑：</strong></p>
<ol>
<li><p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</p>
</li>
<li><p>代表编程语言：JavaScript，Java，C++，C#</p>
</li>
<li><p>面向对象编程就是抛开计算机思维，使用生活中的思维方式进行的编程方式。生活中，每一件事物都有自己的状态和行为，因此可以这么说——万事万物皆对象。</p>
</li>
<li><p>基本特征：封装，继承，多态。</p>
</li>
</ol>
<h5 id="面向过程编辑与面向对象编辑的区别和联系"><a href="#面向过程编辑与面向对象编辑的区别和联系" class="headerlink" title="面向过程编辑与面向对象编辑的区别和联系"></a>面向过程编辑与面向对象编辑的区别和联系</h5><ol>
<li><p>面向过程编程：注重解决问题的步骤，分析问题需要的每一步，实现函数依次调用。</p>
</li>
<li><p>面向对象编辑：注重问题中的对象，分析问题中对象的联系，实现对象间的通讯解决问题。</p>
</li>
<li><p>面向对象编程淡化过程，强调对象。    更接近我们日常处理问题的方式。</p>
</li>
<li><p>面向过程：所有功能都是在需要使用的时候才开发，相当于去餐馆点菜，现点现做，需要等待时间。</p>
</li>
<li><p>面向对象：在正式开发之前，就先把所有需要使用的功能开发好，并以属性或者方法的形式存放在一个对象中，在实际开发的时候根据需要来调用写好的功能。相当于去麦当劳，食物都是做好的，去了直接就可以吃了。</p>
</li>
<li><p>面向对象无法取代面向过程，他们是相辅相成的。面向对象关注于从宏观上把握事物之间的关系，在具体到如何实现某个细节时，仍然采用面向过程的思维方式。面向对象如果离开了面向过程，就无法实现真正的落地，成为无源之水。</p>
</li>
</ol>
<h3 id="面向对象——类和对象"><a href="#面向对象——类和对象" class="headerlink" title="面向对象——类和对象"></a>面向对象——类和对象</h3><p><strong>类：</strong>类是一组具有相同特征和事物的抽象。</p>
<p>一个对象所包含的所有数据和代码可以通过类来构成一个用户定义的数据类型。事实上，对象就是类类型（class type）的变量。一旦定义了一个类，就可以创建这个类的多个对象，每个对象与一组数据有关，而这个数据的类型在类中定义。</p>
<p><strong>对象：</strong>对象是类的实例，对象是具体的事物。</p>
<p>在一个面向对象的系统中，对象是运行期的基本实体。它可以用来表示一个人，一辆车，一个账户，或者是需要被程序处理的东西。它也可以用来表示用户定义的数据，例如一个变量，列表等。在面向对象的程序设计中，问题的分析一般以对象及对象间的自然联系为依据。对象在内存中占有一定空间，并且具有一个与之关联的地址。</p>
<p>当一个程序运行时，对象之间通过互发消息来相互作用。每个对象都包含数据以及操作这些数据的代码。即使不了解彼此的数据和代码的细节，对象之间依然可以相互作用，所要了解的只是对象能够接受的消息的类型，以及对象返回的响应的类型，虽然不同的人会以不同的方法来实现。
　　</p>
<h3 id="Object对象的使用"><a href="#Object对象的使用" class="headerlink" title="Object对象的使用"></a>Object对象的使用</h3><p><strong>只有对象才有属性和方法，基本数据类型没有。</strong></p>
<p><strong>string等类型能够使用的方法来自于他自身的构造器，在基本数据类型调用方法时会临时创建一个对象出来，在方法完成时，自动销毁。</strong></p>
<pre>
    //使用Object声明对象
    var student = new Object();
    //简写方法
    var student = {};
    //设置属性
    student.name = "小明";
    student.sex = "男";
    //方法
    student.say = function(){
        alert(this.name+"\n"+this.sex);
    }
    //调用方法
    student.say();
</pre>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre>
    function Student(name,sex){
        //内部创建对象
        var obj = {};
        //属性
        obj.name = name;
        obj.sex = sex;
        //方法
        obj.showName = function(){
            alert(obj.name);
        }
        obj.showSex = function(){
            alert(obj.sex);
        }
        //返回对象
        return obj;
    }
    //使用工厂模式创建对象
    var xiaoMing = Student("小明","男");
    //调用方法
    xiaoMing.showName();
    xiaoMing.showSex();
</pre>

<h3 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h3><p><strong>构造函数：</strong>用来构建对象的函数。</p>
<ol>
<li><p>为了区别普通函数，构造函数的函数名首字母规定为大写形式。</p>
</li>
<li><p>构造函数必须使用new运算符来调用执行（实例化对象）。</p>
</li>
</ol>
<p><strong>原型：prototype</strong> 当我们声明一个类时，同时生成了一个对应的原型。</p>
<ol>
<li><p>通过new实例化出来的对象，其属性和行为来自于两个部分，一部分来自于构造函数，另一部分来自于原型。</p>
</li>
<li><p>原型本身就是一个对象。</p>
</li>
<li><p>通过prototype可以指向这个原型，原型可以通过constructor指向类（构造函数）。</p>
</li>
</ol>
<p>一般来说，我们习惯把属性放在构造函数中，把方法放在原型中。目的是节省性能，因为实例化对象不一定每个都需要方法。</p>
<p><strong>原型链：</strong>原型链是指对象在访问属性或方法时的查找方式。</p>
<ol>
<li><p>当访问一个对象的属性或方法时，会现在对象自身上查找属性或方法是否存在，如果存在就使用自身的属性或方法；如果不存在就去创建的构造函数的原型对象中查找，如果有就使用，没有就继续向上查找，以此类推，知道找到为止。如果到顶层对象中还找不到，则返回undefined。（当原型和构造函数都有的时候，找到的是其本身，因为原型链是先从对象自身查找的）</p>
</li>
<li><p>原型链最顶层为Object构造函数的prototype原型对象，给Object.prototype添加属性或方法可以被除null和undefined之外的所有数据类型对象使用。</p>
</li>
</ol>
<pre>
    //创建构造函数  类似 类
    //特征：首字母大写
    //一般情况下，把属性放在构造函数中，把方法放在原型中
    function Student(name,sex){
        this.name = name;
        this.sex = sex;
    }
    Student.prototype = {
        say : function(){
            alert("姓名："+this.name+"\n"+"性别："+this.sex);
        }
    }
    //向原型中追加属性或方法，必须放在原型对象下方，否则就会被覆盖
    Student.prototype.height = "180cm";
    //实例化对象
    var student = new Student("小红","女");
    //调用方法
    student.say();
</pre>

<h3 id="面向对象基本特征"><a href="#面向对象基本特征" class="headerlink" title="面向对象基本特征"></a>面向对象基本特征</h3><h5 id="特征一：封装"><a href="#特征一：封装" class="headerlink" title="特征一：封装"></a>特征一：封装</h5><p>封装的目的在于将信息隐藏。封装机制将数据和代码捆绑到一起，避免了外界的干扰和不确定性，可以创建对象。简单的说，一个对象就是一个封装了数据和操作这些数据的代码的逻辑实体。</p>
<p>在一个对象内部，某些代码和（或）某些数据是可以私有的，不能被外部访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外改变或错误的使用了对象的私有部分。在传统的面向对象的语言中，一般会提供public、protected、private等关键字来声明属性和方法的公开性；而JavaScript没有这些关键字，主要通过作用域来实现公有或私有。</p>
<p>因为私有属性及私有方法只能在构造函数内部进行直接访问，因此通过公有的方法去访问私有的属性。</p>
<p><strong>set方法</strong>专门给私有属性赋值的方法称为set方法。</p>
<p><strong>get方法</strong>专门获取私有属性的方法称为get方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Women(name,sex)&#123;</span><br><span class="line">	//共有属性</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.sex = sex;</span><br><span class="line">	//私有属性</span><br><span class="line">	var _age = &quot;20&quot;;</span><br><span class="line">	//公有方法</span><br><span class="line">	this.eat = function()&#123;</span><br><span class="line">	alert(&quot;吃了啥&quot;)；</span><br><span class="line">	//私有方法</span><br><span class="line">	var fight = function()&#123;</span><br><span class="line">		alert(&quot;go go go!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	//私有属性及私有方法只能在构造函数内部进行直接访问。</span><br><span class="line">	//set方法及其合法性</span><br><span class="line">	this.setAge = function(age)&#123;</span><br><span class="line">		if(parseInt(age)&gt;100 || parseInt(age)&lt;0)&#123;</span><br><span class="line">			alert(&quot;年龄不合法&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		_age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	//get方法</span><br><span class="line">	this.getAge = function()&#123;</span><br><span class="line">		return _age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="特征二：继承"><a href="#特征二：继承" class="headerlink" title="特征二：继承"></a>特征二：继承</h5><p>继承可以让某个类型的对象获得另一个对象的属性的方法。继承的特性是子类具有父类所有的特征和行为，继承的目的是找到类之间的共性，精简代码。</p>
<p>我们可以向一个已经存在的类中添加新的特性，而不必改变这个类。这个可以通过这个类派生一个新类来实现。这个新的类将具有原来的那个类的特性，以及新的特性。继承的魅力和强大在于它允许程序员利用已经存在的类，并且可以以某种方式修改这个类，而不会影响其他的东西。</p>
<p>构造函数的继承，使用call，apply方法</p>
<pre>
    function Person(name,age){
        this.name = name;
        this.age = age;
    }
    //Student继承于Person
    function Student(name,age,sex){
        //call方法
        Person.call(this,name,age);
        //apply方法（两种写法）
        Person.apply(this,arguments)
        Person.apply(this,[name,age]);
        this.sex = sex;
    }
    var stu = new Student("小明","18","男");
    console.log(stu);
</pre>

<p><strong>原型的继承：</strong>因为创建的对象由构造函数和原型两部分的属性和行为组成，所以需要进行原型的继承。JavaScript中的数据几乎都是对象，存在一个根对象Object.prototype。</p>
<p><strong>传值：</strong>简单数据类型之间的赋值为传值。</p>
<p><strong>传址：</strong>复杂数据类型之间的赋值为传址。</p>
<pre>
    var a = 1;
    var b = a;
    b = 5;
    alert(a);
    //a将值直接复制给b，修改b的值并不会影响a。
    var arr1 = [1,2,3];
    var arr2 = arr1;
    arr2[0] = 10;
    alert(arr1[0]);
    //arr1将值的地址复制给arr2，修改arr2的值会影响到arr1的值。
</pre>

<p>因此，原型的继承应用以下方式：</p>
<pre>
    function Person(name){
        this.name = name;
    }
    Person.prototype.say = function(){
        alert("person");
    }
    function Student(name,age){
        Person.apply(this,arguments);
        this.age = age;
    }
    //创建一个空的构造函数
    function Lin(){};
    //通过赋值实现传址，Lin的原型就跟Person的一样了
    Lin.prototype = Person.prototype;
    //通过实例化出来的对象的存储地址就是新的地址了，同时赋值给Student实现了传址，所以Student.prototype的地址就是
    //实例化出来的对象的地址，则其的内容就跟被继承的原型的内容一致，实现了原型继承
    Student.prototype = new Lin();
    //再更改其constructor属性，达到跟创建原型完全一致
    Student.prototype.constructor = Student;
    var person = new Person("小明");
    var student = new Student("小红","18");
    student.say();
</pre>

<p><strong>克隆</strong></p>
<p><strong>JSON.stringify()：</strong>将[]或{}的对象转换成字符串形式的值。</p>
<p><strong>JSON.parse()：</strong>将字符串形式的[]或{}值转换成对象。</p>
<p><strong>克隆实现原理：</strong>利用字符串赋值为传值的特点，先将对象转换成字符串形式，然后将字符串形式的值再转换成对象。</p>
<p><strong>兼容问题：</strong>不支持低版本IE浏览器。</p>
<pre>
    function Person(name){
        this.name = name;
    }
    var person = new Person("小明");
    var str = JSON.stingify(person);
    var newObj = JSON.parse(str);
    newObj.name = "小红";
    console.log(person.name);
</pre>

<h5 id="特征三：多态"><a href="#特征三：多态" class="headerlink" title="特征三：多态"></a>特征三：多态</h5><p>多态指事物具有不同形式的能力。比如说加法操作，如果操作的是数字，则为两个数字求和；如果操作的是字符串，则将连接两个字符串。</p>
<p>多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着虽然针对不同对象的具体操作不同，但通过一个公共的类，那些操作可以通过相同的方式予以调用。多态在实现继承的过程中被广泛应用。</p>
<p>面向对象设计语言支持多态，术语称之为”one interface muliple method（一个接口，多个实现）”。简单来说，多态机制允许通过相同的接口引发一组相关但不相同的动作，通过这种方式，可以减少代码的复杂度。在某个特定的情况下应该做出怎样的动作，这由编译器决定，而不需要程序员手工干预。</p>
<h3 id="typeof查看数据类型的改进"><a href="#typeof查看数据类型的改进" class="headerlink" title="typeof查看数据类型的改进"></a>typeof查看数据类型的改进</h3><p>typeof可以准确判断出简单数据类型，但对复杂数据类型的判断相对比较模糊。例如：数组对象/时间对象/正则对象/Math对象等都返回的是“object”。因此封装一个函数来查询具体类型。</p>
<p>其原理为Object对象的prototype的toString()方法会返回一个表示对象本身类型的字符串，再通过截取即可。</p>
<pre>
    function type(obj){
        var o = {};
        var str = o.toString.call(obj).slice(8,-1).toLowerCase();
        return str;
    }
    var arr = [1,2,3];
    console.log(type(arr));
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/24/JavaScript面向对象/" data-id="cisn3bgnd001659e8ag0x4sye" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScriptRegExp正则对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/10/JavaScriptRegExp正则对象/" class="article-date">
  <time datetime="2016-08-10T13:12:13.000Z" itemprop="datePublished">2016-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/10/JavaScriptRegExp正则对象/">JavaScriptRegExp正则对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><p><strong>RegExp对象</strong>表示正则表达式，是对字符串执行模式匹配的强大工具。</p>
<p><strong>构造正则表达式方式：</strong></p>
<ol>
<li><p>直接定义：<code>var reg=/pattern/attributes;</code></p>
</li>
<li><p>创建RegExp对象：<code>var reg=new RegExp(pattern,attributes);</code></p>
</li>
</ol>
<p>参数pattern是一个字符串，指定了正则表达式的模式或其他正则表达式；</p>
<p>参数attribute是一个可选字符串，包含属性”g”、”i”和”m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript标准化之前，不支持m属性。如果pattern是正则表达式，而不是字符串，则必须省略该参数。</p>
<p><strong>RegExpObject.test(string)</strong></p>
<p>检测字符串是否匹配某个模式，是则返回true，否则返回false。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>正则检测方式，如果不设置全局检测，那么只要检测到一次就结束。</p>
<pre>
    i        不区分大小写

    g        全局匹配

    m        多行匹配
</pre>

<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><pre>
    .        查找单个字符，所有非换行和行结束符的字符

    \w        查找数字字母下划线

    \W        查找非数字字母下划线

    \d        查找数字

    \D        查找非数字

    \s        查找空格

    \S        查找非空格

    \b        检测单词开头或者结尾是否有

    \B        不处于单词开头或结尾的

    \0        空字符串，也相当于NUL

    \n        查找换行符

    \f        查找换页符

    \t        查找制表符

    \v        查找垂直制表符

    \xxx    查找以八进制数xxx规定的字符

    \xdd    查找以十六进制数dd规定的字符

    \uxxxx    查找以十六进制数xxxx规定的Unicode字符
</pre>

<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><pre>
    n+        包含一个及以上（至少一个）n的字符串

    n*        包含零个或多个n的字符串

    n?        包含零个或一个n的字符串

    n{X}    包含X个n的序列的字符串

    n{X,Y}    包含X到Y个n的序列的字符串

    n{X,}    包含至少X个n的序列的字符串

    n$        匹配任何结尾为n的字符串

    ^n        匹配任何开头为n的字符串

    ?=n        匹配任何其后紧接指定字符串n的字符串

    ?!n        匹配任何其后没有紧接指定字符串n的字符串
</pre>

<h3 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h3><pre>
    [abc]    查找方括号之间的任何字符

    [^abc]    查找任何不在方括号之间的字符

    [0-9]    查找任何从0至9的数字

    [a-z]    查找任何从小写a到小写z的字符

    [A-Z]    查找任何从大写A到大写Z的字符

    [A-Za-z]查找任何从大写A到小写Z的字符

    ()        查找任何指定的选项
</pre>

<h3 id="支持正则表达式的方法"><a href="#支持正则表达式的方法" class="headerlink" title="支持正则表达式的方法"></a>支持正则表达式的方法</h3><p><strong>stringObject.search(regexp)</strong></p>
<p>返回第一个与regexp相匹配的起始位置，如果没有则返回-1。<code>此方法不支持全局匹配</code>，如需忽略大小写，需添加i。</p>
<p><strong>stringObject.match(regexp)</strong></p>
<p>返回存放匹配结果的数组。数组内容依赖于regexp是否有全局标志g。</p>
<p><strong>stringObject.replace(regexp,replacement)</strong></p>
<p>返回一个新的字符串，用replacement替换regexp第一次匹配或所有匹配之后得到的。</p>
<p><strong>stringObject.spilt(separator,howmany)</strong></p>
<p>前面已讲过，在此不再一一赘述。</p>
<pre>
    //判断手机号
    var reg1=/^1[34578]\d{9}/;
    //判断固定电话号码
    var reg2=/(^0\d{2,3}-[1-9]\d{6,7}$)|(^[1-9]\d{6,7}$)/;
    //判断汉字
    var reg3=/[\u4e00-\u9fa5]+/g;

    //选择替换关键字
    var reg4=/哈哈|呵呵|这个是/g;
    var str="这个是的呵呵，这个哈哈是的，呵呵";
    var newStr=str.replace(reg4,function(sr){
        var str="";
        for(var i=0;i&lt;sr.length;i++){
            str+="*";
        }
        return str;
    })
    console.log(newStr);
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/10/JavaScriptRegExp正则对象/" data-id="cisn3bgmg000l59e8jvl54fj1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScriptTouch事件、陀螺仪、加速度、cookie和localStorage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/06/JavaScriptTouch事件、陀螺仪、加速度、cookie和localStorage/" class="article-date">
  <time datetime="2016-08-06T13:49:25.000Z" itemprop="datePublished">2016-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/06/JavaScriptTouch事件、陀螺仪、加速度、cookie和localStorage/">JavaScriptTouch事件、陀螺仪、加速度、cookie和localStorage</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Touch事件"><a href="#Touch事件" class="headerlink" title="Touch事件"></a>Touch事件</h3><p>touch事件在用户触摸屏幕时触发。其与mouse事件的最大区别在于其支持<em>多点触控</em>。主要有以下几种：</p>
<p>touchstart：相当于mousedown事件</p>
<p>touchmove：相当于mousemove事件</p>
<p>touchend：相当于mouseup事件</p>
<p>应用如下：</p>
<pre>
    &lt;style&gt;
        .divtouch{
            width:300px;
            height:500px;
            border:1px solid blue;
            position:relative;
            margin:0 auto;
        }
        .divtouch p{
            font-size:30px;
            text-align:center;
        }
        .divtouch div{
            position:absolute;
            width:50px;
            height:50px;
            background-color:pink;
            top:0;
            left:0;
        }
    &lt;/style&gt;
    &lt;div class="divtouch"&gt;
        &lt;p&gt;&lt;/p&gt;
        &lt;div&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var para=document.querySelector(".divtouch p");
        var divtouchBlock=document.querySelector(".divtouch div");
        var s={
            startX:0,
            startY:0,
            endX:0,
            endY:0,
            disX:0,
            disY:0,
            ofl:0,
            oft:0,
        }
        divtouchBlock.addEventListener("touchstart",function(e){
            var e=e||window.event;
            para.innerHTML=e.touches.length+"根手指";
            s.ofl=divtouchBlock.offsetLeft;
            s.oft=divtouchBlock.offsetTop;
            s.startX=e.touches[0].clientX;
            s.startY=e.touches[0].clientY;
            e.preventDefault();
        },false)
        document.addEventListener("touchmove",function(e){
            var e=e||window.event;
            if(e.touches.length!=1){
                return;
            }
            s.endX=e.touches[0].clientX;
            s.endY=e.touches[0].clientY;
            s.disX=s.endX-s.startX+s.ofl;
            s.disY=s.endY-s.startY+s.oft;
            divtouchBlock.style.left=s.disX+"px";
            divtouchBlock.style.top=s.disY+"px";
        },false)
    &lt;/script&gt;
</pre>

<pre>
    <style>
        .divtouch{
            width:300px;
            height:500px;
            border:1px solid blue;
            position:relative;
            margin:0 auto;
        }
        .divtouch p{
            font-size:30px;
            text-align:center;
        }
        .divtouch div{
            position:absolute;
            width:50px;
            height:50px;
            background-color:pink;
            top:0;
            left:0;
        }
    </style>
    <div class="divtouch">
        <p></p>
        <div></div>
    </div>
    <script>
        var para=document.querySelector(".divtouch p");
        var divtouchBlock=document.querySelector(".divtouch div");
        var s={
            startX:0,
            startY:0,
            endX:0,
            endY:0,
            disX:0,
            disY:0,
            ofl:0,
            oft:0,
        }
        divtouchBlock.addEventListener("touchstart",function(e){
            var e=e||window.event;
            para.innerHTML=e.touches.length+"根手指";
            s.ofl=divtouchBlock.offsetLeft;
            s.oft=divtouchBlock.offsetTop;
            s.startX=e.touches[0].clientX;
            s.startY=e.touches[0].clientY;
            e.preventDefault();
        },false)
        document.addEventListener("touchmove",function(e){
            var e=e||window.event;
            if(e.touches.length!=1){
                return;
            }
            s.endX=e.touches[0].clientX;
            s.endY=e.touches[0].clientY;
            s.disX=s.endX-s.startX+s.ofl;
            s.disY=s.endY-s.startY+s.oft;
            divtouchBlock.style.left=s.disX+"px";
            divtouchBlock.style.top=s.disY+"px";
        },false)
    </script>
</pre>

<h3 id="设备事件——方向API（陀螺仪）"><a href="#设备事件——方向API（陀螺仪）" class="headerlink" title="设备事件——方向API（陀螺仪）"></a>设备事件——方向API（陀螺仪）</h3><p>方向事件指DeviceOrientationEvent，其触发事件为<strong>deviceorientation</strong></p>
<pre>
    if(window.DeviceOrientationEvent){
        window.addEventListener("deviceorientation",function(e){
            var e=e||window.event;
            e.alpha;//0~360度，0度指向正北方（Z轴）
            e.beta;//设备前后转-180~180度（X轴）
            e.gamma;//设备左右转-90~90度（Y轴）
        },false)
    }
</pre>

<h3 id="设备事件——加速度API"><a href="#设备事件——加速度API" class="headerlink" title="设备事件——加速度API"></a>设备事件——加速度API</h3><p>加速度事件指DeviceMotionEvent，其触发事件为<strong>devicemotion</strong></p>
<pre>
    if(window.DeviceMotionEvent){
        window.addEventListener("devicemotion",function(e){
            var e=e||window.event;
            e.acceleration.x;//加速度，x代表x方向
            e.acceleration.y;
            e.acceleration.z;

            e.accelerationIncludingGravity.x;//重力加速度，x轴代表x方向
            e.accelerationIncludingGravity.y;
            e.accelerationIncludingGravity.z;
        },false)
    }
</pre>

<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个cookie。可以使用JavaScript来创建和取回cookie的值。</p>
<p><strong>服务器环境下才能设置cookie，每一个域名下最多20个cookie，每一个cookie不超过4kb。</strong></p>
<p>每个cookie都是一个名/值对，如果要一次存储多个名/值对，可以使用分号加空格（; ）隔开。<code>document.cookie=&quot;userId=123; userName=Jack&quot;;</code></p>
<p><strong>cookie的名或值中不能使用分号（;）、逗号（,）、等号（=）及空格。如需存储用escape()函数进行编码，从而避免乱码出现。</strong></p>
<pre>
    //设置cookie的名字，值，过期时间
    setCookie("usename/password",userVal,10);
    function setCookie(key,value,days){
        var newDate=new Date();
        var nowDay=nowDate.getDate();
        nowDate.setDate(nowDay+days);
        document.cookie=key+"="+value+";expires"+nowDate;
    }
    //删除cookie，将date设置为过去的时间来删除
    setCookie("name","",-1);
</pre>

<h3 id="localStorageb本地存储"><a href="#localStorageb本地存储" class="headerlink" title="localStorageb本地存储"></a>localStorageb本地存储</h3><p>localStorage是HTML5提供的在客户端存储数据的新方法，<strong>localStorage是没有时间限制的数据存储</strong></p>
<p>比cookie方便之处在于可以直接调用和删除。</p>
<pre>
    //设置localStorage
    localStorage.username=user.value;
    //获取localStorage
    alert(localStorage.username);
    //删除localStorage
    localStorage.removeItem("username");
</pre>

<p>可通过如下代码来对访问页面次数进行计数：</p>
<pre>
    &lt;script&gt;
        if(localStorage.pagecount){
            localStorage.pagecount=Number(localStorage.pagecount)+1;//localStorage.pagecount为自定义参数
        }else{
            localStorage.pagecount=1;
        }
        console.log(localStorage.pagecount);
    &lt;/script&gt;
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/06/JavaScriptTouch事件、陀螺仪、加速度、cookie和localStorage/" data-id="cisn3bgmm000q59e8pezg2t0n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript滚轮事件的封装和滚轮轮播图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/05/JavaScript滚轮事件的封装和滚轮轮播图/" class="article-date">
  <time datetime="2016-08-05T12:03:48.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/JavaScript滚轮事件的封装和滚轮轮播图/">JavaScript滚轮事件的封装和滚轮轮播图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="滚轮事件的封装"><a href="#滚轮事件的封装" class="headerlink" title="滚轮事件的封装"></a>滚轮事件的封装</h3><p>因鼠标滚动事件区分为火狐滚轮事件和非火狐滚轮事件，而且其向上滚动和向下滚动的正负值不同，因此封装滚轮事件以便调用。</p>
<pre>
    function mouseWheel(obj,fn){
        var isDown=true;
        var isFirefox=navigator.userAgent.search("Firefox")==-1?false:true;
        if(isFirefox){
            obj.addEventListener("DOMMouseScroll",wheel,false);
        }else{
            obj.onmousewheel=wheel;
        }

        function wheel(e){
            var e=e||window.event;
            if(isFirefox){
                isDown=e.detail>0?true:false;
            }else{
                isDown=e.wheelDelta>0?false:true;
            }
            fn.call(obj,e,isDown);
        }
    }
</pre>

<h3 id="滚轮轮播图"><a href="#滚轮轮播图" class="headerlink" title="滚轮轮播图"></a>滚轮轮播图</h3><p>通过利用上图的滚轮事件的封装函数，来设置轮播图的纵向滚动。</p>
<pre>
    &lt;style&gt;
        .wheelSlide{
            width:800px;
            height:500px;
            position:relative;
            overflow:hidden;
            border:1px solid gold;
            margin:0 auto;        
        }
        .wheelSlides{
            width:800px;
            height:2500px;
            position:absolute;
            top:0;
            left:0;
            transition-duration:3s;
        }
        .wheelSlides div{
            width:800px;
            height:500px;
            line-height:500px;
            text-align:center;
            font-size:100px;
            color:white;
        }
        .wheelSlides div:nth-child(1){
            background:paleturquoise;
        }
        .wheelSlides div:nth-child(2){
            background:lightpink;
        }
        .wheelSlides div:nth-child(3){
            background:palegreen;
        }
        .wheelSlides div:nth-child(4){
            background:peachpuff;
        }
        .wheelSlides div:nth-child(5){
            background:plum;
        }
    &lt;/style&gt;
    &lt;div class="wheelSlide"&gt;
        &lt;div class="wheelSlides"&gt;
            &lt;div&gt;1&lt;/div&gt;
            &lt;div&gt;2&lt;/div&gt;
            &lt;div&gt;3&lt;/div&gt;
            &lt;div&gt;4&lt;/div&gt;
            &lt;div&gt;5&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var wheelSlide=document.querySelector(".wheelSlide");
        var wheelSlides=document.querySelector(".wheelSlides");
        var wheelSlidesDiv=document.querySelectorAll(".wheelSlides div");
        var s={
            isAct:false,
            index:0,
        }

        mouseWheel(wheelSlide,function(e,isDown){
            if(s.isAct){
                return;
            }
            s.isAct=!s.isAct;
            setTimeout(function(){
                s.isAct=!s.isAct;
            },3000)
            if(isDown){
                s.index++;
                s.index=s.index&gt;wheelSlidesDiv.length-1?wheelSlidesDiv.length-1:s.index;
            }else{
                s.index--;
                s.index=s.index&lt;0?0:s.index;
            }
            wheelSlides.style.top=-s.index*500+"px";
            e.preventDefault();
        })

        function mouseWheel(obj,fn){
            var isDown=true;
            var isFirefox=navigator.userAgent.search("Firefox")==-1?false:true;
            if(isFirefox){
                obj.addEventListener("DOMMouseScroll",wheel,false);
            }else{
                obj.onmousewheel=wheel;
            }

            function wheel(e){
                var e=e||window.event;
                if(isFirefox){
                    isDown=e.detail&gt;0?true:false;
                }else{
                    isDown=e.wheelDelta&gt;0?false:true;
                }
                fn.call(obj,e,isDown);
            }
        }
    &lt;/script&gt;
</pre>

<pre>
    <style>
        .wheelSlide{
            width:800px;
            height:500px;
            position:relative;
            overflow:hidden;
            border:1px solid gold;
            margin:0 auto;        
        }
        .wheelSlides{
            width:800px;
            height:2500px;
            position:absolute;
            top:0;
            left:0;
            transition-duration:3s;
        }
        .wheelSlides div{
            width:800px;
            height:500px;
            line-height:500px;
            text-align:center;
            font-size:100px;
            color:white;
        }
        .wheelSlides div:nth-child(1){
            background:paleturquoise;
        }
        .wheelSlides div:nth-child(2){
            background:lightpink;
        }
        .wheelSlides div:nth-child(3){
            background:palegreen;
        }
        .wheelSlides div:nth-child(4){
            background:peachpuff;
        }
        .wheelSlides div:nth-child(5){
            background:plum;
        }
    </style>
    <div class="wheelSlide">
        <div class="wheelSlides"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></div>
    </div>
    <script>
        var wheelSlide=document.querySelector(".wheelSlide");
        var wheelSlides=document.querySelector(".wheelSlides");
        var wheelSlidesDiv=document.querySelectorAll(".wheelSlides div");
        var s={
            isAct:false,
            index:0,
        }

        mouseWheel(wheelSlide,function(e,isDown){
            if(s.isAct){
                return;
            }
            s.isAct=!s.isAct;
            setTimeout(function(){
                s.isAct=!s.isAct;
            },3000)
            if(isDown){
                s.index++;
                s.index=s.index>wheelSlidesDiv.length-1?wheelSlidesDiv.length-1:s.index;
            }else{
                s.index--;
                s.index=s.index<0?0:s.index;
            }
            wheelSlides.style.top=-s.index*500+"px";
            e.preventDefault();
        })

        function mouseWheel(obj,fn){
            var isDown=true;
            var isFirefox=navigator.userAgent.search("Firefox")==-1?false:true;
            if(isFirefox){
                obj.addEventListener("DOMMouseScroll",wheel,false);
            }else{
                obj.onmousewheel=wheel;
            }

            function wheel(e){
                var e=e||window.event;
                if(isFirefox){
                    isDown=e.detail>0?true:false;
                }else{
                    isDown=e.wheelDelta>0?false:true;
                }
                fn.call(obj,e,isDown);
            }
        }
    </script>
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/05/JavaScript滚轮事件的封装和滚轮轮播图/" data-id="cisn3bgn0000y59e8ne1xojhe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScriptCallback回调函数和事件委托的封装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/03/JavaScriptCallback回调函数和事件委托的封装/" class="article-date">
  <time datetime="2016-08-03T11:02:34.000Z" itemprop="datePublished">2016-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/03/JavaScriptCallback回调函数和事件委托的封装/">JavaScriptCallback回调函数和事件委托的封装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="callback回调函数"><a href="#callback回调函数" class="headerlink" title="callback回调函数"></a>callback回调函数</h3><p>由于JavaScript语句是按照次序执行的，因为动画未完成，动画之后的语句可能会产生错误或页面冲突。为避免这种情况，可以使用callback函数。</p>
<p><strong>callback回调函数</strong>就是放在另一个函数（parent）的参数列表中，作为参数传递给parent，然后在parent函数体的某个位置执行。</p>
<pre>
    function fn(a,b,fn2){
        console.log(a+b);
        fn2();
    }
    function callBack(){
        console.log("我是函数参数")
    }
    fn(a,b,callBack);//在这里就callBack就是回调函数
</pre>

<h3 id="事件委托的封装"><a href="#事件委托的封装" class="headerlink" title="事件委托的封装"></a>事件委托的封装</h3><pre>
    function targetHandle(type,child,parent,fn){
        //type事件类型 child
        if(parent.addEventListener){//判断浏览器是否为IE浏览器，此处为非IE
            parent.addEventListener(type,function(e){
                var e=e||window.event;
                var target=e.target;
                //事件想绑定到child上
                for(var i=0;i&lt;child.length;i++){
                    //判断触发事件的元素是否是想绑定事件的元素或者是想绑定元素事件的子代
                    if(cp(target,child[i])){
                        fn.call(child[i]);//改变this指向，否则指向window
                    }
                }
            },false)
        }else{
            parent.attachEvent(type,function(e){
                var e=e||window.event;
                var target=e.target;
                for(var i=0;i&lt;child.lenthli++){
                    if(cp(target,child[i])){
                        fn.call(child[i]);
                    }
                }
            })
        }
    }

    function cp(child,parent){
        if(child==parent){
            return true;
        }else{
            while(child.parentNode){
                if(child.parentNode==parent){
                    return true;
                    break;
                }else{
                    child=child.parentNode;
                }
            }
        }
    }

    例如：
    var wrap=document.querySelector("ul");
    var lis=wrap.getElementsByTagName("li");
    targetHandle("click",lis,wrap,function(){
        console.log(this);
    })    
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/03/JavaScriptCallback回调函数和事件委托的封装/" data-id="cisn3bgmf000k59e8izdw6s7s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript事件流、事件类型、事件对象和事件委托" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/30/JavaScript事件流、事件类型、事件对象和事件委托/" class="article-date">
  <time datetime="2016-07-30T08:28:55.000Z" itemprop="datePublished">2016-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/30/JavaScript事件流、事件类型、事件对象和事件委托/">JavaScript事件流、事件类型、事件对象和事件委托</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="JavaScript事件流"><a href="#JavaScript事件流" class="headerlink" title="JavaScript事件流"></a>JavaScript事件流</h3><p>事件流描述的是在页面中接受事件的顺序，分为<strong>事件冒泡</strong>和<strong>事件捕获</strong>。</p>
<p><code>事件冒泡</code>指事件一级一级的往上触发，一直到根元素为止</p>
<p><code>事件捕获</code>指事件从根元素开始触发，一直到触发元素的事件为止</p>
<h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DOM0级事件	直接在元素上绑定，绑定多个后面会覆盖前面</span><br><span class="line">			例如：</span><br><span class="line">			wrap.onclick=function()&#123;</span><br><span class="line">				alert(&quot;a&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			wrap.onclick=function()&#123;</span><br><span class="line">				alert(&quot;b&quot;);//仅仅会弹出b，因为覆盖前面</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">DOM2级事件	可以多次绑定</span><br><span class="line"></span><br><span class="line">	addEventListener(type,fn,bol);		绑定事件</span><br><span class="line">	removeEventListener(type,fn,bol);	解除事件</span><br><span class="line">		type：事件类型</span><br><span class="line">		fn：  事件语句，必须是对应的非匿名函数</span><br><span class="line">		bol： 事件触发机制  false事件冒泡 true事件捕获</span><br><span class="line">		解除检测某个事件语句，type、fn、bol都必须对应相同</span><br><span class="line">		</span><br><span class="line">	attachEvent(type,fn);	IE上的DOM2级绑定事件</span><br><span class="line">	detachEvent(type,fn);	IE上的DOM2级解除事件</span><br><span class="line">	</span><br><span class="line">	wrap.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">		//匿名函数的匿名参数，表示触发的事件对象</span><br><span class="line">		//为了兼容IE低版本，需要使用window.event</span><br><span class="line">		var e=e||window.event;</span><br><span class="line">		console.log(e.currentTarget);</span><br><span class="line">	&#125;,false)</span><br></pre></td></tr></table></figure>
<p><strong>函数不添加()，就是执行代码块；添加()，就是执行结果</strong></p>
<h3 id="event对象"><a href="#event对象" class="headerlink" title="event对象"></a>event对象</h3><p>event对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p>
<p><strong>事件通常与函数结合使用，函数不会在事件发生前被执行！</strong></p>
<h5 id="event方法"><a href="#event方法" class="headerlink" title="event方法"></a>event方法</h5><p><strong>event.initEvent();</strong>初始化新创建的event对象的属性</p>
<p><strong>event.preventDefault();</strong>阻止默认事件</p>
<p><strong>event.stopPropagation();</strong>阻止事件继续派发</p>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><h6 id="UI事件：当用户与页面上的元素交互时触发"><a href="#UI事件：当用户与页面上的元素交互时触发" class="headerlink" title="UI事件：当用户与页面上的元素交互时触发"></a>UI事件：当用户与页面上的元素交互时触发</h6><p><strong>load事件：</strong>当页面加载完毕之后触发</p>
<p><strong>resize事件：</strong>当浏览器窗口改变大小时候触发</p>
<p><strong>scroll事件：</strong>当用户滚动一个带滚动条的元素时触发</p>
<h6 id="鼠标事件：通过鼠标在页面上执行操作"><a href="#鼠标事件：通过鼠标在页面上执行操作" class="headerlink" title="鼠标事件：通过鼠标在页面上执行操作"></a>鼠标事件：通过鼠标在页面上执行操作</h6><p><strong>contextmenu事件：</strong>弹出右键菜单</p>
<p><strong>click事件：</strong>对象被点击时发生（在同一元素发生鼠标按下事件后又发生鼠标放开事件时才发生的）</p>
<p><strong>mousedown事件：</strong>鼠标被按下时触发</p>
<p><strong>mousemove事件：</strong>在鼠标指针移动时触发</p>
<p><strong>mouseup事件：</strong>在鼠标按键松开时触发</p>
<p><strong>mouseover事件：</strong>鼠标指针移动到指定的对象上时触发（鼠标指针穿过任何子元素，同样会触发事件）</p>
<p><strong>mouseenter事件：</strong>当鼠标指针进入（穿过）指定元素时触发（只有鼠标指针穿过被选元素时才会触发）</p>
<p><strong>mouseout事件：</strong>无论鼠标指针离开被选元素还是任何子元素都会触发mouseout事件（鼠标指针离开任何子元素，同样会触发事件）</p>
<p><strong>mouseleave事件：</strong>只有在鼠标指针离开被选元素时，才会触发mouseleave事件（只有在鼠标指针离开被选元素时，才会触发）</p>
<p><strong>mousewheel事件：</strong>非火狐滚轮事件</p>
<p><strong>DOMMouseScroll事件：</strong>火狐滚轮事件</p>
<h6 id="键盘事件：通过键盘在页面上执行操作"><a href="#键盘事件：通过键盘在页面上执行操作" class="headerlink" title="键盘事件：通过键盘在页面上执行操作"></a>键盘事件：通过键盘在页面上执行操作</h6><p><strong>keydown事件：</strong>某个键盘按键被按下触发</p>
<p><strong>keyup事件：</strong>某个键盘按键被松开触发</p>
<p><strong>keypress事件：</strong>某个键盘被按下并松开触发</p>
<h6 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h6><p><strong>focus事件：</strong>在对象获得焦点时发生</p>
<p><strong>blur事件：</strong>在对象失去焦点时发生</p>
<p><strong>change事件：</strong>当元素的值发生改变时在元素失去焦点时发生（可以作用于<code>&lt;input&gt;&lt;textarea&gt;&lt;keygen&gt;&lt;select&gt;</code>元素）</p>
<p><strong>input事件：</strong>当元素的值发生改变时立即发生（可以作用于<code>&lt;input&gt;&lt;textara&gt;</code>元素）</p>
<h6 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h6><p><strong>touch事件：</strong>在用户触摸屏幕（页面）时触发</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p><strong>clientX</strong> 当事件被触发时，鼠标指针的水平坐标。相对于可视区域</p>
<p><strong>clientY</strong> 当事件被触发时，鼠标指针的竖直坐标。相对于可视区域</p>
<p><strong>layerX</strong> 鼠标相对于定位父级border左上角的起始位置（包括border）</p>
<p><strong>layerY</strong> 鼠标相对于定位父级border左上角的起始位置（包括border）</p>
<p><strong>offsetX</strong> 鼠标相对于触发事件元素的位置，从内容区域的左上角开始定位（不包括border）</p>
<p><strong>offsetY</strong> 鼠标相对于触发事件元素的位置，从内容区域的左上角开始定位（不包括border）</p>
<p><strong>pageX</strong> 鼠标在页面上的位置，从页面左上角开始定位。相对于整个页面</p>
<p><strong>pageY</strong> 鼠标在页面上的位置，从页面左上角开始定位。相对于整个页面</p>
<p><strong>screenX</strong> 鼠标在显示屏幕上的坐标，相对于屏幕</p>
<p><strong>screenY</strong> 鼠标在显示屏幕上的坐标，相对于屏幕</p>
<p><strong>movementX</strong> 鼠标的移动距离 <code>mousemove事件特有</code></p>
<p><strong>movementY</strong> 鼠标的移动距离 <code>mousemove事件特有</code></p>
<p><strong>X</strong> 在IE里独有，跟layerX一个效果</p>
<p><strong>Y</strong> 在IE里独有，跟layerY一个效果</p>
<p><strong>alrKey</strong> 返回当事件被触发时，”ALT”是否被按下</p>
<p><strong>button</strong> 当事件被触发时，哪个鼠标按钮被点击（0鼠标左键，1鼠标中键，2鼠标右键）IE（1鼠标左键，4鼠标中键，2鼠标右键）</p>
<p><strong>bubbles</strong> 表明事件是否冒泡，是则返回true；否则返回false</p>
<p><strong>cancelable</strong> 表明事件是否拥有可取消的默认动作</p>
<p><strong>ctrlKey</strong> 当事件触发时，”CTRL”键是否被按下</p>
<p><strong>currentTarget</strong> 返回其监听器触发的节点，即当前处理该事件的元素、文档或窗口。也就是事件绑定的元素，和this是一样的（在捕获和气泡阶段非常有用，在这两个节点不同于target属性）</p>
<p><strong>defaultPrevented</strong> 是否阻止了默认事件</p>
<p><strong>detail</strong> 判断滚轮向上或向下 火狐浏览器 正值表示页面向下滑动</p>
<p><strong>wheelDelta</strong> 判断滚轮向上或向下 非火狐浏览器 负值表示页面向下滑动</p>
<p><strong>eventPhase</strong> 返回事件传播的当前阶段。分别为捕获阶段、正常事件派发和气泡阶段</p>
<p><strong>formElement</strong> 对于mouseover和mouseout事件，fromElement引用移出鼠标的元素</p>
<p><strong>isTrusted</strong> 表明当前事件是否由用户行为触发</p>
<p><strong>metaKey</strong> 当事件被触发时，”meta”键是否被按下</p>
<p><strong>path</strong> 层级关系</p>
<p><strong>relatedTarget</strong> 返回与事件的目标节点相关的节点。对于mouseover事件来说，该属性是鼠标指针移到目标节点上时所离开的那个节点。对于mouseout事件来说，该属性是离开目标时，鼠标指针进入的节点。对于其他类型的事件来说，这个属性没有用。</p>
<p><strong>returnValue</strong> IE属性，它的值比事件句柄的返回值优先级高。把这个属性设置为false，可以取消发生事件的源元素的默认动作。</p>
<p><strong>shiftKey</strong> 事件被触发时，”SHIFT”键是否被按下</p>
<p><strong>srcElement</strong> IE属性，对于生成事件的window对象、document对象或element对象的引用</p>
<p><strong>target</strong> 返回触发此事件的元素（事件的目标节点）</p>
<p><strong>timeStamp</strong> 返回一个时间戳，距离页面打开的毫秒数</p>
<p><strong>toElement</strong> 对于mouseover和mouseout事件，该属性引用移入鼠标的元素</p>
<p><strong>type</strong> 当前event对象表示的事件的名称（如：”click”、”submit”、”load”等）</p>
<p><strong>view</strong> 根元素</p>
<p><strong>which</strong> 返回哪个键被按下了</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用冒泡原理，把事件加到父级上，触发执行效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	.btntarget&#123;</span><br><span class="line">		width:150px;</span><br><span class="line">		height:40px;</span><br><span class="line">		background-color:gray;</span><br><span class="line">		border:none;</span><br><span class="line">		font-size:20px;</span><br><span class="line">		border-radius:10px;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;button class=&quot;btntarget&quot;&gt;增加一个li&lt;/button&gt;</span><br><span class="line">&lt;ul class=&quot;ultarget&quot;&gt;</span><br><span class="line">	&lt;li&gt;我是li1&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;我是li2&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;我是li3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var btnli=document.querySelector(&quot;.btntarget&quot;);</span><br><span class="line">	var ul=document.querySelector(&quot;.ultarget&quot;);</span><br><span class="line">	var lis=ul.getElementsByTagName(&quot;li&quot;);</span><br><span class="line">	var num=4;</span><br><span class="line">	btnli.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">		var newLi=document.createElement(&quot;li&quot;);</span><br><span class="line">		newLi.innerHTML=&quot;我是li&quot;+num;</span><br><span class="line">		ul.appendChild(newLi);</span><br><span class="line">		num++;</span><br><span class="line">	&#125;,false)</span><br><span class="line">	ul.onclick=function()&#123;</span><br><span class="line">		var e=e||window.event;</span><br><span class="line">		var targets=e.target||e.srcElement;</span><br><span class="line">		for(var i=0;i&lt;lis.length;i++)&#123;</span><br><span class="line">			if(targets==lis[i])&#123;</span><br><span class="line">				alert(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<pre>
    <style>
        .btntarget{
            width:150px;
            height:40px;
            background-color:gray;
            border:none;
            font-size:20px;
            border-radius:10px;
        }
    </style>
    <button class="btntarget">增加一个li</button>
    <ul class="ultarget"><li>我是li1</li><li>我是li2</li><li>我是li3</li></ul>
    <script>
        var btntarget=document.querySelector(".btntarget");
        var ultarget=document.querySelector(".ultarget");
        var listarget=ultarget.getElementsByTagName("li");
        var num=4;
        btntarget.addEventListener("click",function(){
            var newLi=document.createElement("li");
            newLi.innerHTML="我是li"+num;
            ultarget.appendChild(newLi);
            num++;
        },false)
        ultarget.onclick=function(){
            var e=e||window.event;
            var targets=e.target||e.srcElement;
            for(var i=0;i<listarget.length;i++){
                if(targets==listarget[i]){
                    alert(i);
                }
            }
        }
    </script>
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/30/JavaScript事件流、事件类型、事件对象和事件委托/" data-id="cisn3bgmn000r59e8himh703g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScriptBOM浏览器对象模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/30/JavaScriptBOM浏览器对象模型/" class="article-date">
  <time datetime="2016-07-30T01:11:21.000Z" itemprop="datePublished">2016-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/30/JavaScriptBOM浏览器对象模型/">JavaScriptBOM浏览器对象模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="BOM简介"><a href="#BOM简介" class="headerlink" title="BOM简介"></a>BOM简介</h3><p>BOM：Browser Object Model 是浏览器对象模型，浏览器对象模型提供了独立与内容的，可以与浏览器窗口进行互动的对象结构，BOM由多个对象构成，其中代表浏览器窗口的window对象是BOM的顶层对象，其他对象都是该对象的子对象。</p>
<h3 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h3><h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><p>window是根对象，screen、navigator、location、history都属于window，只不过我们使用这些方法的时候可以省略前面的window。</p>
<p>window.close();关闭浏览器窗口</p>
<p>window.open();打开一个新的浏览器窗口或查找一个已命名的窗口</p>
<p>window.innerWidth;浏览器可视区的宽度（在IE8及以下有兼容问题）</p>
<p>window.innerHeight;浏览器可视区的高度（在IE8及以下有兼容问题）</p>
<h5 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h5><p>screen对象包含有关客户端显示屏幕的信息。</p>
<p>screen.width;显示器的宽</p>
<p>screen.height;显示器的高</p>
<p>screen.availWidth;浏览器的屏幕可用的宽度</p>
<p>screen.availHeight;浏览器的屏幕可用的高度</p>
<h5 id="navigator浏览器信息（-important）"><a href="#navigator浏览器信息（-important）" class="headerlink" title="navigator浏览器信息（!important）"></a>navigator浏览器信息（!important）</h5><p>navigator.appCodeName;浏览器的代码名</p>
<p>navigator.appVersion;浏览器的版本信息</p>
<p>navigator.platform;浏览器的操作系统和（或）硬件平台</p>
<p>navigator.userAgent;浏览器用于HTTP请求的用户代理头的值</p>
<h5 id="location路径信息"><a href="#location路径信息" class="headerlink" title="location路径信息"></a>location路径信息</h5><p>location.host;返回主机名及端口</p>
<p>location.name;返回主机名</p>
<p><strong>location.hash;</strong>锚 指#及其后面的值，只有一个值</p>
<p><strong>location.href;</strong>完整的链接（URL）</p>
<p>location.pathname;当前URL的路径部分</p>
<p>location.port;端口号</p>
<p>location.protocol;当前URL的协议</p>
<p><strong>location.search</strong>;问号（?）开始的URL（查询部分），到#为止</p>
<p>location.assign();加载新文档</p>
<p><strong>location.reload();</strong>重新加载当前页面</p>
<p>location.replace();用新文档替换当前文档</p>
<h5 id="history历史记录"><a href="#history历史记录" class="headerlink" title="history历史记录"></a>history历史记录</h5><p>history.length;返回浏览器历史列表中的URL数量</p>
<p>history.back();加载history列表中的前一个URL</p>
<p>history.forward();加载history列表中的下一个URL</p>
<p>history.go();加载history列表中的某个具体页面</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/30/JavaScriptBOM浏览器对象模型/" data-id="cisn3bgmj000o59e8dqq4tc7h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/01/PHP初了解/">PHP初了解</a>
          </li>
        
          <li>
            <a href="/2016/08/28/HTML5canvas标签和JavaScript的结合运用/">HTML5canvas标签和JavaScript的结合运用</a>
          </li>
        
          <li>
            <a href="/2016/08/26/jQuery函数的封装/">jQuery函数的封装</a>
          </li>
        
          <li>
            <a href="/2016/08/24/JavaScript面向对象/">JavaScript面向对象</a>
          </li>
        
          <li>
            <a href="/2016/08/10/JavaScriptRegExp正则对象/">JavaScriptRegExp正则对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 刘晓萌<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>